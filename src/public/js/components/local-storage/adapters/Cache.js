// Generated by CoffeeScript 2.7.0
define(['underscore', 'lzs'], function(_, LZString) {
  var Cache;
  return Cache = class Cache {
    constructor(options) {
      var settings;
      settings = {
        namespace: 'global',
        backend: false,
        separator: '-'
      };
      if (_.isString(options)) {
        options.namespace = options;
      }
      if (options) {
        _.extend(settings, options);
      }
      this.separator = settings.separator;
      this.setNamespace(settings.namespace);
      if (settings.backend) {
        this.setBackend(settings.backend);
      }
      this.storage = window.localStorage;
      this.compressor = LZString;
      this.latestSet = 0;
      this.latestSetAll = 0;
      this.latestSaveAll = 0;
      this.latestSyncAll = 0;
      _.bindAll(this);
    }

    clearAllKeysInNS() {
      var all, i, key, len, oldKeyValPairs, self, thisNS;
      self = this;
      all = Object.keys(self.storage);
      thisNS = all.filter(function(k) {
        return k.indexOf(self.namespace) > -1;
      });
      console.log(thisNS);
      oldKeyValPairs = thisNS.reduce((function(m, k) {
        m[k] = self.storage[k];
        return m;
      }), {});
      for (i = 0, len = thisNS.length; i < len; i++) {
        key = thisNS[i];
        self.storage.removeItem(key);
      }
      return oldKeyValPairs;
    }

    setBackend(backend) {
      if (_.isFunction(backend)) {
        return this.backend = backend;
      } else {
        throw new TypeError("(Cache)(setBackend): backend is not a function");
      }
    }

    setNamespace(namespace) {
      if (_.isString(namespace)) {
        return this.namespace = this._dasherize(namespace);
      } else {
        throw new TypeError("(Cache)(setNamespace): namespace is not a string");
      }
    }

    _ns(key) {
      return `${this.namespace}.${this._makeValidKey(key)}`;
    }

    _makeValidKey(key) {
      if (_.isString(key)) {
        return this._dasherize(key);
      } else {
        throw new TypeError(`(Cache)(_makeValidKey): key '${key}' is not a string`);
      }
    }

    _dasherize(string) {
      return string.replace(/_/g, this.separator);
    }

    get(key) {
      var item;
      key = this._makeValidKey(key);
      if (!this.isObjectExpired()) {
        if (this.cachedObject[key]) {
          return this.compressor.decompress(this.cachedObject[key]);
        }
      }
      item = this.storage.getItem(this._ns(key));
      if (!item) {
        return null;
      }
      return JSON.parse(this.compressor.decompress(item));
    }

    set(key, value) {
      this.latestSet = new Date().getTime();
      if (value) {
        this.storage.setItem(this._ns(key), this.compressor.compress(JSON.stringify(value)));
      } else {
        this.storage.removeItem(this._ns(key));
      }
      return value;
    }

    setAll(items) {
      if (_.isObject(items)) {
        return _.each(items, (key, item) => {
          key = this._makeValidKey(key);
          return this.set(key, item);
        });
      } else {
        throw new TypeError("(Cache)(setAll): items is not an object");
      }
    }

    append(key, item) {
      var arr;
      arr = this.get(key);
      if (_.isArray(arr)) {
        arr.push(item);
        return this.set(key, arr);
      } else if (arr === null) {
        arr = [item];
        return this.set(key, arr);
      } else {
        throw new TypeError('(Cache)(append): array expected, instead: ' + typeof arr);
      }
    }

    prepend(key, item) {
      var arr;
      arr = this.get(key);
      // type check
      if (_.isArray(arr)) {
        arr.unshift(item);
        return this.set(key, arr);
      } else if (arr === null) {
        arr = [item];
        return this.set(key, arr);
      } else {
        throw new TypeError('(Cache)(prepend): array expected');
      }
    }

    extend(key, object) {
      var current;
      if (!_.isObject(object)) {
        throw new TypeError(`(Cache)(extend): object argument '${object}' is not an object`);
      }
      current = this.get(key);
      // type check
      if (_.isObject(current)) {
        _.extend(current, object);
        return this.set(key, current);
      } else {
        throw new TypeError(`(Cache)(extend): current value for key '${key}' is not an object`);
      }
    }

    all(isObjectReturned) {
      var arr, keys, nsLength, obj, objKeys;
      isObjectReturned = !!isObjectReturned || false;
      if (isObjectReturned && !this.isObjectExpired()) {
        return this.cachedObject;
      }
      if (!this.isArrayExpired()) {
        return this.cachedArray;
      }
      objKeys = Object.keys(this.storage);
      nsLength = this.namespace.length;
      keys = _.filter(objKeys, (key) => {
        return (key.substring(0, nsLength)) === this.namespace;
      });
      if (_.isEmpty(objKeys)) {
        return null;
      }
      if (isObjectReturned) {
        obj = {};
        _.each(keys, (key) => {
          key = key.substring(nsLength + 1, key.length);
          return obj[key] = this.get(key);
        });
        return this._cacheObject(obj);
      } else {
        arr = [];
        _.each(keys, (key) => {
          key = key.substring(nsLength + 1, key.length);
          return arr.push(this.get(key));
        });
        return this._cacheArray(arr);
      }
    }

    _cacheArray(array) {
      this.cachedArray = array;
      this.cachedArrayTime = new Date().getTime();
      return array;
    }

    _cacheObject(object) {
      this.cachedObject = object;
      this.cachedObjectTime = new Date().getTime();
      return object;
    }

    isArrayExpired() {
      if (this.cachedArrayTime) {
        return this.cachedArrayTime >= this.latestSet;
      }
      return true;
    }

    isObjectExpired() {
      if (this.cachedObjectTime) {
        return this.cachedObjectTime >= this.latestSet;
      }
      return true;
    }

    isEmpty() {
      return Object.keys(this.storage) === null;
    }

    data() {
      return {
        namespace: this.namespace,
        latestSet: this.latestSet,
        latestSetAll: this.latestSetAll,
        latestSaveAll: this.latestSaveAll,
        latestSyncAll: this.latestSyncAll
      };
    }

    // TODO: save method
    // TODO: sync method

      // @description sync with backend
    syncAll() {
      var allItemsFromBackend;
      if (this.backend) {
        allItemsFromBackend = this.backend({
          method: 'syncAll',
          items: this.all(true),
          data: this.data
        });
        if (allItemsFromBackend) {
          this.setAll(allItemsFromBackend);
        }
        return this.latestSyncAll = new Date().getTime();
      } else {
        throw new Error("(Cache)(syncAll): no backend is set");
      }
    }

    // @description one way saveAll call to backend
    saveAll() {
      if (this.backend) {
        this.backend({
          method: 'saveAll',
          items: this.all(true),
          data: this.data
        });
        // set the latest saveAll
        return this.latestSaveAll = new Date().getTime();
      } else {
        throw new Error('(Cache)(saveAll): no backend is set');
      }
    }

  };
});
